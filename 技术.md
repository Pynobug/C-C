# Day1

## 1. 微服务

### 1.1 为什么使用微服务架构

单体架构只适用于小的电商平台，比如只有用户、订单、商品等模块。但是如果是一个大型的电商平台，需要购物车、支付、还有手工制品电商平台中的审核模块、手工人入驻模块等等。如果用简单的单体项目，不适合团队的开发和维护（虽然只有我一个人），所以决定使用微服务架构的模式，把每个功能模块拆分成多个微服务进行开发。

https://b11et3un53m.feishu.cn/wiki/UMgpwmmQKisWBIkaABbcwAPonVf

https://gitee.com/huyi612/hmall/tree/master/user-service/src/main/java/com/hmall/user/domain/



## 2. Mybatis-Plus

mybatis-plus是无侵入的，不影响mybatis的使用；

mybatis-plus的作用是简化开发



### 2.1 使用方法

引入依赖，定义Mapper接口继承BaseMapper



###  2.2 常见注解

通过扫描实体类，基于反射获取实体类信息作为数据库表信息

![image-20241021195436660](../../../AppData/Roaming/Typora/typora-user-images/image-20241021195436660.png)

不符合规定的话，需要添加注解

![image-20241021195531647](../../../AppData/Roaming/Typora/typora-user-images/image-20241021195531647.png)

@TableId 中，有 idType 属性：

- AUTO：自增
- INPUT：自己输入
- ASSIGN_ID：默认雪花算法（mp定义的）



使用 @TableField 的场景

- 成员变量名和数据库字段名不一致
- 成员变量名用 is 开头，且是布尔值
- 成员变量名与数据库关键字冲突
- 成员变量不是数据库字段（数据库中没有这个字段）





### 2.3 mp 配置

![image-20241021201220917](../../../AppData/Roaming/Typora/typora-user-images/image-20241021201220917.png)



### 2.4 条件构造器（核心功能）

![image-20241023145750604](../../../AppData/Roaming/Typora/typora-user-images/image-20241023145750604.png)

**案例**

![image-20241023145948976](../../../AppData/Roaming/Typora/typora-user-images/image-20241023145948976.png)

用构造器实现

```java
QueryWrapper<User> wrapper = new QueryWrapper<User>()
    .select("id", "username", "info", "balance")
    .like("username", "o")
    .ge("balance", 1000);
List<User> users = userMapper.select(wrapper);
users.foreach(System.out::println);
```



```java
User user = new User();
user.setBalance(2000);
QueryWrapper<User> wrapper = new QueryWrapper<User>().eq("username", "jack");
userMapper.update(user, wrapper); 
```



**UpdateWrapper**

![image-20241023151410846](../../../AppData/Roaming/Typora/typora-user-images/image-20241023151410846.png)

```java
List<Long> ids = List.of(1L, 2L, 4L);
UpdateWrapper<User> wrapper = new UpdateWrapper<User>()
    .setSql("balance = balance - 200")
    .in("id", ids);
userMapper.update(null, wrapper);
```



为了避免硬编码，建议使用 `LambdaQueryWrapper`

**例如**

```java
QueryWrapper<User> wrapper = new QueryWrapper<User>()
    .select("id", "username", "info", "balance")
    .like("username", "o")
    .ge("balance", 1000);
List<User> users = userMapper.select(wrapper);
users.foreach(System.out::println);

--------------------------------------------------------------------
    
LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<User>()
    .select(User::getId, User::getUsername, User::getInfo, User::getBalance)
    .like(User::getUsername, "o")
    .ge(User::getBalance, 1000);
List<User> users = userMapper.select(wrapper);
users.foreach(System.out::println);
```

基于反射





### 2.5 自定义 Sql

由于复杂的业务场景下，mp构建的wrapper中会有一些计算等等复杂条件，而一般是在业务层中定义的，我们不希望逻辑代码写入业务层中，就需要自定义wrapper，也就是

where 中的条件交给mp，其他的自定义 （拼接）

![image-20241023153357657](../../../AppData/Roaming/Typora/typora-user-images/image-20241023153357657.png)





### 2.6 Service 接口

IService接口

- 增：save
- 删：remove
- 改：saveOrUpdate，update
- 查：查单个：get
  -  查多个：list
  - 查数量：count
  -  分页查：page
- 复杂条件：lambda

```java
public interface IUserService extends IService<User>{}
```

```java
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService{}
```







# Day2

## 1. ES elasticsearch

分布式搜索 ES elasticsearch



### 1.1 初识ES elasticsearch

#### **1. 什么是 ES**

elasticsearch 是一款非常强大的开源搜索引擎，可以帮助我们从海量数据中快速找到所需要的内容



#### **2. 什么是 elastic stack（ELK）**

- 数据可视化: Kibana
- 存储、计算、搜索数据: Elasticsearch (核心)
- 数据抓取: Logstash, Beats



#### **3. 什么是Lucence**

- Lucence的优势：
  - 易扩展
  - 高性能（基于倒排索引）
- Lucence的缺点：
  - 只限于Java开发
  - 学习曲线陡峭
  - 不支持水平扩展（分布式）

**Elasticsearch基于Lucence进行二次开发**

**相比于Lucence，elasticserach具备以下优势：**

- 支持分布式，可水平扩展
- 提供Restful接口，可被任何语言调用

___



**倒排索引**

**1.  什么是 正向索引和倒排索引？**

- 传统数据库（如Mysql）采用正向索引；但一般内容长的不加索引，即便添加了索引，模糊查询时也可能失效（逐条查询，性能差）
- 倒排索引：把文档（document）中的内容根据词义分成词条（term）

![image-20241022232136648](../../../AppData/Roaming/Typora/typora-user-images/image-20241022232136648.png)

查询时：
词条不会重复，根据词条查找
1.内容  -->   2.分词  -->  3.查询（去词条列表查询文档id）  -->  4.根据文档id查询文章  -->  5.存入结果集





#### **2.  什么是文档？**

- **文档：**

  - ES 是面向文档存储的，可以是数据库中的一条商品数据，一个订单信息等等。

  - 文档数据会被序列化为json格式后存储在 ES 里

#### **3. 什么是索引？**

- **索引：**
  - 相同类型的文档的集合

![image-20241022232401894](../../../AppData/Roaming/Typora/typora-user-images/image-20241022232401894.png)

![image-20241022232457130](../../../AppData/Roaming/Typora/typora-user-images/image-20241022232457130.png)



**架构**

- mysql： 擅长事务类型操作，有ACID特性，可以确保数据的安全和一致性
- elasticsearch： 擅长海量的数据的分析、搜索和计算

![image-20241022232651944](../../../AppData/Roaming/Typora/typora-user-images/image-20241022232651944.png)



# Day3

## 1. Redis（缓存中间件）

**SQL  VS  NOSQL**

![image-20241027150511462](../../../AppData/Roaming/Typora/typora-user-images/image-20241027150511462.png)



**redis 的特征**

- 键值（key-value）型，value支持多种不同的数据结构，功能丰富
- 单线程，每个命令具备原子性
- 低延迟，速度快（虽然是单线程，到是是 基于**内存**、IO 多路复用、良好的编码）
  - redis是基于内存存储，mysql是基于磁盘，这是redis性能好的主要原因
- 支持数据持久化（避免宕机导致的数据丢失）
- 支持主从集群、分片集群
- 支持多语言客户端 





**redis 数据结构**

redis是key-value 的数据库，key一般是 String， value类型多种多样

![image-20241027175613416](../../../AppData/Roaming/Typora/typora-user-images/image-20241027175613416.png)

命令行操作：https://redis.io/commands





### 1. 常用数据类型和命令

#### 1. 通用命令

- KEYS：查看符合模板的所有key（`KEYS pattern`）（不建议在生产环境设备上使用）
- DEL：删除一个指定的key（`DEL k1 k2 k3`）
- EXISTS：判断一个key是否存在（`EXISTS key [key ...]`）
- EXPIRE：给一个key设置有效期，有效期到期该key 会被自动删除
- TTL：查看一个key 的剩余有效期



#### 2. String类型常见命令

String 类型，也就是字符串类型，是 redis 中最简单的存储类型

其 value 是字符串， 不过根据字符串的格式不同，有可以分为 3 类

- string：普通字符串
- int：整数类型，可以做自增、自减操作
- float：浮点类型，可以做自增、自减操作

不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型最大空间不能超过512m



**常见命令**

- SET：添加或修改已经存在的一个String类型的键值对（`SET key value`）
- GET： 根据key 获取 value
- MSET： 批量添加（`MSET k1 v1 k2 v2 `）
- MGET：批量获取
- INCR： 让一个整形的 key 自增1
- INCRBY： 指定自增的数量（`INCRBY age 2 `）
- INCRBYFLOAT：让一个浮点类型的数字自增长
- SETNX：添加一个 String 类型的键值对，前提是这个key 不存在，否则不添加
- SETEX： 添加一个 String 类型的键值对， 并指定有效期





#### 3. key 的格式

- 一般是按照  `[项目名]:[业务名]:[类型]:[id]`

- 例如

  ```sql
  SET project:user:1 '{"id": 1, "name": "Jack", "age", 21}'
  ```

  这样的层级结构的 key ，在图形化页面中也能自动生成文件的层级存储





#### 4. Hash 类型

就是散列表，其 value 是一个无序字典，类似于 Java 中的 HashMap

![image-20241029122106935](../../../AppData/Roaming/Typora/typora-user-images/image-20241029122106935.png)



#### **Hash 的常见命令**

- HSET key field value
- HGET key field
- HMSET key field value field value
- HMGET key field field
- HGETALL key
- HKEYS key
- HVALS key
- HINCRBY key field increment(步长)
- HSETNX key field value （如果该字段已经存在则不执行）



#### 5. List 类型

类似于 Java 中的 LinkedList，双向链表，支持正向检索和反向检索

**特征**

- 有序
- 可以重复
- 插入和删除快
- 查询速度一般



**常见命令**

![image-20241029170628438](../../../AppData/Roaming/Typora/typora-user-images/image-20241029170628438.png)

![image-20241029171432043](../../../AppData/Roaming/Typora/typora-user-images/image-20241029171432043.png)



#### 6. set 类型

和 HashSet 类似，可以看作是 value为 null 的HashMap

**特征**

- 无序
- 元素不可重复
- 查找速度快
- 支持交集、并集、差集等功能



**常见命令**

![image-20241029204147334](../../../AppData/Roaming/Typora/typora-user-images/image-20241029204147334.png)

#### 7. SortedSet 类型

类似于 Java 中的 TreeSet，但底层实现不一样

TreeSet：红黑树

SortedSet：每一个元素带上score值，基于score排序，基于SkipList（跳表）+ 哈希表



**特征**

- 可排序
- 元素不重复
- 查询速度快



**常见命令**

![image-20241029205311928](../../../AppData/Roaming/Typora/typora-user-images/image-20241029205311928.png)





### 2. Redis 客户端（Java）

项目开发中肯定是需要通过编码的方式

![image-20241029210246036](../../../AppData/Roaming/Typora/typora-user-images/image-20241029210246036.png)

#### 2.1 Jedis

1. 引入依赖

2. 建立连接

   ```Java
   private Jedis jedis;
   
   @BeforeEach //测试的注释
   void setUp() {
       //建立连接
       jedis = new Jedis("192.xxx.xxx.xxx", 6379);
       //设置密码
       jedis.auth("123321");
       //选择库
       jedis.select(0); 
   }
   ```

3. 使用（Jedis 的命令和 redis 相同）

4. 释放资源

   ```java
   @AfterEach
   void tearDown() {
   	//释放资源
       if (jedis != null) {
           jedis.close();
       }
   }
   ```



**由于 Jedis 本身是线程不安全的，并且频繁的创建和销毁会影响性能，所以我们使用 Jedis 连接池**

![image-20241029221353041](../../../AppData/Roaming/Typora/typora-user-images/image-20241029221353041.png)





#### 2.2  SpringDataRedis

![image-20241029233125560](../../../AppData/Roaming/Typora/typora-user-images/image-20241029233125560.png)

![image-20241029233617420](../../../AppData/Roaming/Typora/typora-user-images/image-20241029233617420.png)

**使用**

1. 引入依赖

   ![image-20241030154410758](../../../AppData/Roaming/Typora/typora-user-images/image-20241030154410758.png)

2. 配置文件

   ![image-20241030154446995](../../../AppData/Roaming/Typora/typora-user-images/image-20241030154446995.png)

3. 注入 RedisTemplate

   ```java
   @Autowired
   private RedisTemplate redisTmplate;
   ```

4. 使用

   ![image-20241030154624552](../../../AppData/Roaming/Typora/typora-user-images/image-20241030154624552.png)



**SpringDataRedis 的序列化方式**

![image-20241030155013006](../../../AppData/Roaming/Typora/typora-user-images/image-20241030155013006.png)

**解决方法**

![image-20241030155328561](../../../AppData/Roaming/Typora/typora-user-images/image-20241030155328561.png)

实现自动序列化和反序列化。

其中还用到了 工厂方法模式和策略模式



**缺点**

![image-20241030164638792](../../../AppData/Roaming/Typora/typora-user-images/image-20241030164638792.png)

![image-20241030164832479](../../../AppData/Roaming/Typora/typora-user-images/image-20241030164832479.png)

 ![image-20241030165116643](../../../AppData/Roaming/Typora/typora-user-images/image-20241030165116643.png)





#### 2.3 应用场景

电商

- 商品信息缓存
- 优惠券秒杀



**缓存（读写性能较高）**

- 优点
  - 降低了后端的负载
  - 提高读写效率，降低响应时间
- 缺点
  - 数据一致性成本
  - 代码维护成本
  - 运维成本

![image-20241030180250865](../../../AppData/Roaming/Typora/typora-user-images/image-20241030180250865.png)



更新缓存的策略

![image-20241031191521686](../../../AppData/Roaming/Typora/typora-user-images/image-20241031191521686.png)



右边可能性低

所以最后的 **方案** 是：

![image-20241031191739163](../../../AppData/Roaming/Typora/typora-user-images/image-20241031191739163.png)



**缓存三兄弟**

-  ***缓存穿透***

  查询一个缓存中和数据库中都没有的数据，先查询缓存，未命中则穿透缓存查询数据库，如果被恶意查询，数据库有可能宕机

- **解决方案**

  - 缓存空数据，这样做的好处就是实现简单，维护方便，只需要缓存空数据即可；缺点就是可能会造成大量的资源浪费和多余的空间存储成本，可以设置一个超时时间 TTL。 也会造成短期的数据不一致情况，比如说刚查询完是空数据，缓存存入空数据，这时候插入数据库，这样就造成了数据不一致的情况。

  - 第二种方法就是使用布隆过滤器，在客户端和 redis缓存中间添加一层 布隆过滤器 （bitmap位图），但也有可能误判或者缓存穿透。





- ***缓存雪崩***

  同一时间大量的key过期失效，或者redis宕机，导致大量的请求到达数据库，带来巨大压力

- **解决方案**	

  - 针对同一时间，大量的key失效，我们可以在缓存预热的时候，给key 的过期时间加一个随机值

  - 针对redis宕机，我们可以

    - 利用redis 的集群提高服务的可用性

    - 给缓存业务添加降级限流的策略

    - 给业务添加多级缓存





- ***缓存击穿***

  热点 key 问题。就是一个被高并发访问，并且缓存重建业务比较复杂的 key 失效，在缓存重建的过程中，大量的请求到达数据库

- **解决方案**

  ![image-20241101162344499](../../../AppData/Roaming/Typora/typora-user-images/image-20241101162344499.png)



![image-20241101162400090](../../../AppData/Roaming/Typora/typora-user-images/image-20241101162400090.png)



**我们可以通过工具类来实现功能**





#### 2.4 优惠券秒杀

- **全局唯一 ID**

![image-20241103170849501](../../../AppData/Roaming/Typora/typora-user-images/image-20241103170849501.png)

![image-20241103172236658](../../../AppData/Roaming/Typora/typora-user-images/image-20241103172236658.png)

![image-20241103220722616](../../../AppData/Roaming/Typora/typora-user-images/image-20241103220722616.png)

---



- **秒杀券流程**

  ![image-20241105230459282](../../../AppData/Roaming/Typora/typora-user-images/image-20241105230459282.png)





**超卖问题**（多线程下）

![image-20241105231000575](../../../AppData/Roaming/Typora/typora-user-images/image-20241105231000575.png)

**解决方法**

![image-20241105231207229](../../../AppData/Roaming/Typora/typora-user-images/image-20241105231207229.png)

乐观锁：

![image-20241105231829099](../../../AppData/Roaming/Typora/typora-user-images/image-20241105231829099.png)

![image-20241105231918516](../../../AppData/Roaming/Typora/typora-user-images/image-20241105231918516.png)



---



- **一人一单**（限制一个用户只能对某张券只能下一单）

  ![image-20241105232140164](../../../AppData/Roaming/Typora/typora-user-images/image-20241105232140164.png)

逻辑很简单，在判断订单充足后，判断用户是否买过该优惠券；

但是有线程安全问题，由于跟update无关，我们使用悲观锁 synchronized锁

锁的颗粒度我们设置为 用户id， 但是我们需要注意 toString 方法获取 userId **对象**（锁住的必须是对象），是不同的对象

```java
synchronized(userId.toString().intern())   //去产量池中找到userId的地址
```

有关事务的问题，https://www.bilibili.com/video/BV1cr4y1671t?spm_id_from=333.788.player.switch&vd_source=dfc4468e4ad45e62f6fd91f27cad2e96&p=54



---





但是**集群模式**下还是有线程安全问题

两个及以上的 JVM ，有多套堆，栈，锁监视器，所以简单的加锁并不能解决集群下的线程并发问题

**解决方案（分布式锁）**

![image-20241106121520515](../../../AppData/Roaming/Typora/typora-user-images/image-20241106121520515.png)

![image-20241106122526505](../../../AppData/Roaming/Typora/typora-user-images/image-20241106122526505.png)



---



**基于Redis实现分布式锁**

![image-20241106125116756](../../../AppData/Roaming/Typora/typora-user-images/image-20241106125116756.png)

获取锁的两个命令需要同时成功或同时失败（原子性）

```shell
SET lock thread1 NX EX 10
```



最后，流程如下

![image-20241106125942234](../../../AppData/Roaming/Typora/typora-user-images/image-20241106125942234.png)

释放锁的时候要判断一下当前线程和持有锁线程是否一致

但线程 id 是有问题的，因为线程 id 是递增的，在集群的情况下，可能出现重复，所以使用 UUID

但还有可能出现问题，我们需要整个过程是原子性的，redis 提供了 **Lua** 脚本

---



**Lua 脚本**

```shell
EVAL "return redis.call('set', KEYS[1], ARGV[1])" 1 name Rose
```

lua 脚本中数组下标从1开始

![image-20241107232453826](../../../AppData/Roaming/Typora/typora-user-images/image-20241107232453826.png)

---



![image-20241107232627226](../../../AppData/Roaming/Typora/typora-user-images/image-20241107232627226.png)

我们把脚本写在resource下

然后通过代码调用

![image-20241107233034796](../../../AppData/Roaming/Typora/typora-user-images/image-20241107233034796.png)



---



![image-20241107233344424](../../../AppData/Roaming/Typora/typora-user-images/image-20241107233344424.png)



---





# Day4



## 1. 微服务



**JMeter 测试并发**

发现单体架构如果一个接口并发太高就把tomcat资源占用完了，影响别的接口的性能



**实体类**

dto, po, vo



### 1.1 远程调用

服务进行拆分后，比如订单信息想得到商品信息，需要服务与服务之间的调用

可以使用 restTemplate发送http请求，通过网络请求调用其他微服务

![image-20241111192751179](../../../AppData/Roaming/Typora/typora-user-images/image-20241111192751179.png)

如果有多个端口负载均衡，以上方法就是有问题的



**解决方案： 注册中心**

![image-20241112135058692](../../../AppData/Roaming/Typora/typora-user-images/image-20241112135058692.png)

![image-20241112135414379](../../../AppData/Roaming/Typora/typora-user-images/image-20241112135414379.png)

#### 1.1.1开源注册中心 – Nacos

- **服务注册**

![image-20241112140752171](../../../AppData/Roaming/Typora/typora-user-images/image-20241112140752171.png)

- **服务发现**

![image-20241112141646656](../../../AppData/Roaming/Typora/typora-user-images/image-20241112141646656.png)



---

以上的方法太繁琐，下面openFeign可以解决



#### 1.1.2 OpenFeign

帮我们写 **http** 请求， 更简单，更优雅

- 旧代码

![image-20241112143942243](../../../AppData/Roaming/Typora/typora-user-images/image-20241112143942243.png)



- 新做法

![image-20241112144023411](../../../AppData/Roaming/Typora/typora-user-images/image-20241112144023411.png)

![image-20241112144344491](../../../AppData/Roaming/Typora/typora-user-images/image-20241112144344491.png)

---

但是，OpenFeign 底层代理发送http请求每次都要建立新的连接，效率不如连接池

![image-20241112145741881](../../../AppData/Roaming/Typora/typora-user-images/image-20241112145741881.png)

---

**连接池**

![image-20241112145843388](../../../AppData/Roaming/Typora/typora-user-images/image-20241112145843388.png)

---



**使用OpenFeign的最佳方式**

新建一个模块，专门做OpenFeign， 项目结构如下

![image-20241112151657700](../../../AppData/Roaming/Typora/typora-user-images/image-20241112151657700.png)

![image-20241112151711058](../../../AppData/Roaming/Typora/typora-user-images/image-20241112151711058.png)



---



**日志**

![image-20241112152526166](../../../AppData/Roaming/Typora/typora-user-images/image-20241112152526166.png)

---



![image-20241112152325861](../../../AppData/Roaming/Typora/typora-user-images/image-20241112152325861.png)

---



![image-20241112152502444](../../../AppData/Roaming/Typora/typora-user-images/image-20241112152502444.png)

---



- Nacos还可以共享配置  https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.player.switch&vd_source=dfc4468e4ad45e62f6fd91f27cad2e96&p=68



#### 1.1.3 网关 Gateway

![image-20241112182844756](../../../AppData/Roaming/Typora/typora-user-images/image-20241112182844756.png)

![image-20241112183012230](../../../AppData/Roaming/Typora/typora-user-images/image-20241112183012230.png)

---

用法

![image-20241112223451866](../../../AppData/Roaming/Typora/typora-user-images/image-20241112223451866.png)





![image-20241112224419968](../../../AppData/Roaming/Typora/typora-user-images/image-20241112224419968.png)





![image-20241112225555569](../../../AppData/Roaming/Typora/typora-user-images/image-20241112225555569.png)



![image-20241112225755726](../../../AppData/Roaming/Typora/typora-user-images/image-20241112225755726.png)



---



**网关的登录校验**

![image-20241113131328378](../../../AppData/Roaming/Typora/typora-user-images/image-20241113131328378.png)

在网关转发请求之前做校验

![image-20241113142329943](../../../AppData/Roaming/Typora/typora-user-images/image-20241113142329943.png)

![image-20241113142551536](../../../AppData/Roaming/Typora/typora-user-images/image-20241113142551536.png)



通过自定义 GlobalFilter 的方式，可以实现在转发之前做用户信息校验

![image-20241113152400909](../../../AppData/Roaming/Typora/typora-user-images/image-20241113152400909.png)



---



登录校验：https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.player.switch&vd_source=dfc4468e4ad45e62f6fd91f27cad2e96&p=64



![image-20241113154438038](../../../AppData/Roaming/Typora/typora-user-images/image-20241113154438038.png)

![image-20241113155537874](../../../AppData/Roaming/Typora/typora-user-images/image-20241113155537874.png)

![image-20241113160604588](../../../AppData/Roaming/Typora/typora-user-images/image-20241113160604588.png)







# Day5

## 1. Lombok

![image-20241115102401219](../../../AppData/Roaming/Typora/typora-user-images/image-20241115102401219.png)

注解在编译阶段会添加代码

![image-20241115102530088](../../../AppData/Roaming/Typora/typora-user-images/image-20241115102530088.png)





# Day6

## 1. 微服务雪崩

![image-20241118203722494](../../../AppData/Roaming/Typora/typora-user-images/image-20241118203722494.png)

- **解决方案（服务保护方案）**

  - 请求限流

  ![image-20241123095108141](../../../AppData/Roaming/Typora/typora-user-images/image-20241123095108141.png)

  - 线程隔离

  ![image-20241123095402083](../../../AppData/Roaming/Typora/typora-user-images/image-20241123095402083.png)

  - 服务熔断

  ![image-20241123095754435](../../../AppData/Roaming/Typora/typora-user-images/image-20241123095754435.png)



![image-20241123100048418](../../../AppData/Roaming/Typora/typora-user-images/image-20241123100048418.png)

![image-20241123100224072](../../../AppData/Roaming/Typora/typora-user-images/image-20241123100224072.png)



## 2. Sentinel

### 1. 下载和安装

- 下载jar包，https://github.com/alibaba/Sentinel/releases

- ```shell
  java -Deserve.port=8090 -Dcsp.sentinal.dashboard.server=localhost:8090 -Dproject.name=sentinal-dashboard -jar sentinal-dashborad.jar
  ```

- 访问：http://localhost:8090  ，账号密码都是sentinel

- 微服务整合，引入依赖

```xml
<!--sentinel-->
<dependency>
	<groupId>com.alibaba.cloud</grpupId>
	<artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```

- 配置

```yaml
spring:
	cloud:
		sentinel:
			transport:
				dashboard: localhost:8090
			http-method-specify: true #是否设置请求方式作为资源名称（Restful风格可能导致路径一样）
```



- 熔断 +（fallback)

![image-20241123124810873](../../../AppData/Roaming/Typora/typora-user-images/image-20241123124810873.png)

![image-20241123124854713](../../../AppData/Roaming/Typora/typora-user-images/image-20241123124854713.png)



---





![image-20241123123300101](../../../AppData/Roaming/Typora/typora-user-images/image-20241123123300101.png)



-  FallbackFactory

![image-20241123123324126](../../../AppData/Roaming/Typora/typora-user-images/image-20241123123324126.png)

![image-20241123123503169](../../../AppData/Roaming/Typora/typora-user-images/image-20241123123503169.png)





## 3. 分布式事务

单体架构的项目想实现事务很容易，利用数据库或者spring中的Trancsational注解就可以实现 ACID 的特性。但是微服务和微服务之间的数据库不一样，想要实现 ACID，则需要实现分布式事务。



### 1. Seata

![image-20241126202142098](../../../AppData/Roaming/Typora/typora-user-images/image-20241126202142098.png)

- **XA模式**

![image-20241127121216886](../../../AppData/Roaming/Typora/typora-user-images/image-20241127121216886.png)

![image-20241127121418887](../../../AppData/Roaming/Typora/typora-user-images/image-20241127121418887.png)



**使用**

![image-20241127121515169](../../../AppData/Roaming/Typora/typora-user-images/image-20241127121515169.png)



- AT模式

![image-20241127122518039](../../../AppData/Roaming/Typora/typora-user-images/image-20241127122518039.png)



![image-20241127122918417](../../../AppData/Roaming/Typora/typora-user-images/image-20241127122918417.png)

**使用**

![image-20241127124827094](../../../AppData/Roaming/Typora/typora-user-images/image-20241127124827094.png)







# Day 7

## RabbitMQ

***rabbitmq  高性能的异步通讯组件***



### 1.  同步调用和异步调用

- 视频通话  同步通讯
- 微信聊天  异步通讯  （并发能力强）



#### 1.1 同步调用

![image-20241202140435969](../../../AppData/Roaming/Typora/typora-user-images/image-20241202140435969.png)

![image-20241202140502631](../../../AppData/Roaming/Typora/typora-user-images/image-20241202140502631.png)





#### 1.2 异步调用

![image-20241202140935561](../../../AppData/Roaming/Typora/typora-user-images/image-20241202140935561.png)

![image-20241202141652442](../../../AppData/Roaming/Typora/typora-user-images/image-20241202141652442.png)



![image-20241202141743167](../../../AppData/Roaming/Typora/typora-user-images/image-20241202141743167.png)



### 2. rabbitmq 快速入门



![image-20241202175803848](../../../AppData/Roaming/Typora/typora-user-images/image-20241202175803848.png)



![image-20241202182648698](../../../AppData/Roaming/Typora/typora-user-images/image-20241202182648698.png)



### 3. 数据隔离(虚拟主机)

- 创建新的用户
- 登录新的用户，并创建虚拟主机
- 交换机会自动创建，自己创建队列并绑定交换机即可



### 4. Java客户端

**Spring AMQP**

**使用**

- 引入依赖

![image-20241206142235582](../../../AppData/Roaming/Typora/typora-user-images/image-20241206142235582.png)

- 配置MQ服务端相关信息

![image-20241206142425135](../../../AppData/Roaming/Typora/typora-user-images/image-20241206142425135.png)

- 发送消息

![image-20241206142645086](../../../AppData/Roaming/Typora/typora-user-images/image-20241206142645086.png)

- 接受消息

![image-20241206144017475](../../../AppData/Roaming/Typora/typora-user-images/image-20241206144017475.png)



![image-20241206144416203](../../../AppData/Roaming/Typora/typora-user-images/image-20241206144416203.png)



### 5. Work Queue 模型

![image-20241206194127364](../../../AppData/Roaming/Typora/typora-user-images/image-20241206194127364.png)

解决消息太多处理不过来的情况（消息堆积）

![image-20241206202617906](../../../AppData/Roaming/Typora/typora-user-images/image-20241206202617906.png)



![image-20241207202403416](../../../AppData/Roaming/Typora/typora-user-images/image-20241207202403416.png)

### 6. Fanout 交换机

![image-20241207203126876](../../../AppData/Roaming/Typora/typora-user-images/image-20241207203126876.png)

交换机的主要目的就是**接收**发送者发送的消息，并将消息**路由**到与其绑定的队列

常见的交换机类型有三种

- Fanout 交换机（广播）
- Direct 交换机（定向）
- Topic 交换机（话题）



**Fanout**

Fanout 交换机 会将接收到的消息 **路由** 到每一个与其绑定的队列，所以也叫广播模式

![image-20241207205325460](../../../AppData/Roaming/Typora/typora-user-images/image-20241207205325460.png)



### 7. Direct 交换机

![image-20241208115209784](../../../AppData/Roaming/Typora/typora-user-images/image-20241208115209784.png)

**使用场景**

- 用户支付成功：需要把消息发送给交易服务，修改订单状态为已支付；发给短信服务，发短信；发给积分服务，给用户加积分；等等

- 用户支付失败：只需要修改交易服务

![image-20241208120222954](../../../AppData/Roaming/Typora/typora-user-images/image-20241208120222954.png)

 ### 8. Topic 交换机

![image-20241208201226888](../../../AppData/Roaming/Typora/typora-user-images/image-20241208201226888.png)



![image-20241208203314623](../../../AppData/Roaming/Typora/typora-user-images/image-20241208203314623.png)



### 9. 声明队列交换机

基于代码生成交换机

![image-20241208205750166](../../../AppData/Roaming/Typora/typora-user-images/image-20241208205750166.png)

![image-20241208205806447](../../../AppData/Roaming/Typora/typora-user-images/image-20241208205806447.png)

使用

![image-20241208210151158](../../../AppData/Roaming/Typora/typora-user-images/image-20241208210151158.png)



Direct 类型的交换机，如果使用声明 Bean 的方法，每次只能绑定一个binding key；所以我们使用注解的方法

![image-20241209130907191](../../../AppData/Roaming/Typora/typora-user-images/image-20241209130907191.png)

### 10. 消息转换器

![image-20241209132910261](../../../AppData/Roaming/Typora/typora-user-images/image-20241209132910261.png)

![image-20241209133000149](../../../AppData/Roaming/Typora/typora-user-images/image-20241209133000149.png)



### 11. 真实业务

![image-20241209192123706](../../../AppData/Roaming/Typora/typora-user-images/image-20241209192123706.png)

变为

![image-20241210173704589](../../../AppData/Roaming/Typora/typora-user-images/image-20241210173704589.png)

使用 direct 交换机 或 topic 交换机

我们使用 direct 交换机





### 12. MQ 高级

我们需要保证消息的可靠性，也就是如何避免消息丢失

